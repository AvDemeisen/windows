<!DOCTYPE html>
<html>
<head>
  <%- include ("../partials/header.ejs") %>
 
</head>

<body>
  <div id="container">
    <div id="background" />
    <div id="overlay" />
    <div class="orientation">
      <span  id="gamma" />
      <span  id="beta" />
    </div>

  </div>
  <style>

  body {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #5A5A5A;
    margin: 0;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    box-sizing: border-box;
  }

#container {
  position: relative;
  height: 100%;
  width: 100%;
  max-height: 1000px;
  max-width: 500px;
  overflow: hidden;
}

#overlay {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  background-size: contain;
  background-position: bottom;
  box-sizing: border-box;
}


#background {
  position: absolute;
  top: 0;
  left: 0;
  padding: 20px;
  height: 100%;
  width: 100%;
  background-size: contain;
  background-position: bottom;
  box-sizing: border-box;
}

.orientation {
  position: absolute;
  display: flex;
  flex-direction: column;
  grid-gap: 5px;
  top: 10%;
  left: 50%;
  background-color: darkslategray;
  color: white;
  padding: 5px;
  font-size: 14px;
}

  </style>
  <script>

const container = document.getElementById('container');
const overlay = document.getElementById('overlay');
const background = document.getElementById('background');

let isDragging = false;
let currentX;
let currentY;
let initialX;
let initialY;
let xOffset = 0;
let yOffset = 0;

const maxAmount = 0.02
const offsetAmount = 0.9;
const sensitivity = 1;

const dragStart = ({clientX, clientY}) => {
  initialX = clientX - xOffset;
  initialY = clientY - yOffset;
  isDragging = true;
};

const dragEnd = (e) => {
  initialX = currentX;
  initialY = currentY;
  
  isDragging = false;
};

const drag = (e) => {
  if (isDragging) {
    e.preventDefault();
    currentX = e.clientX - initialX;
    currentY = e.clientY - initialY;
  
    const maxDrag = container.offsetWidth * maxAmount; 
    if (Math.abs(currentX) > maxDrag || Math.abs(currentY) > maxDrag) return;
    xOffset = currentX;
    yOffset = currentY;
  
    setTranslate(currentX, currentY, overlay);
    setTranslate(currentX * offsetAmount, currentY * offsetAmount, background);
  }
};

const handleOrientation = ({gamma, beta}) => {
  currentX += gamma * sensitivity;
  currentY += beta * sensitivity;

  document.getElementById("gamma").innerHTML = gamma;
  document.getElementById("beta").innerHTML = beta;
  
  setTranslate(currentX, currentY, overlay);
  setTranslate(currentX * offsetAmount, currentY * offsetAmount, background);
}

overlay.addEventListener("mousedown", dragStart);
overlay.addEventListener("mouseup", dragEnd);
overlay.addEventListener("mousemove", drag);
window.addEventListener('deviceorientation', handleOrientation);

const setBackgroundImage = (elm, imageUrl) => {
  elm.style.backgroundImage = `url(${imageUrl})`;
};

const setTranslate = (xPos, yPos, el) => {
  el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
};

const startFlicker = () => {
  setInterval(flicker, Math.random() * 1000 + 100);
};

const flicker = () => {
  const lit = Math.random() >= 0.5;
  const numFlickers = Math.floor(Math.random() * 4) + 1; 
  for (let i = 0; i < numFlickers; i++) {
    setTimeout(changeColor, Math.random() * 1000 + 100, lit); 
  }
};

const changeColor = (lit) => {
  setBackgroundImage(overlay, lit ? '/assets/WALL-LIT.png' : '/assets/WALL-UNLIT.png');
  setBackgroundImage(background, lit ? '/assets/ROOM-LIT.png' : '/assets/ROOM-UNLIT.png');
};

startFlicker();



  </script>
</body>
</html>
